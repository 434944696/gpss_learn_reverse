# 今日头条

> 网站地址： aHR0cHM6Ly93d3cudG91dGlhby5jb20v  
>
> https://github.com/Guapisansan/gpss_learn_reverse 代码在这里，会持续更新逆向案例

**免责声明： 此文档，以及脚本，仅用来对技术的学习与探讨，如有冒犯，请联系作者电话，微信13933566015进行删除**

![image-20230803145011444](./今日头条.assets/image-20230803145011444.png)

来抓一下，信息

## 流程分析

先抓包刷新页面看一下接口吧

![image-20230803145411082](./今日头条.assets/image-20230803145411082.png)

直接开搜索快速定位接口

找到接口后，使用fiddle做重放攻击，看一下相同参数能不能请求成功

https://www.toutiao.com/api/pc/list/feed

![image-20230803145842120](./今日头条.assets/image-20230803145842120.png)

这么看是有数据的

![image-20230803150248815](./今日头条.assets/image-20230803150248815.png)

经过3次重放

![image-20230803150510866](./今日头条.assets/image-20230803150510866.png)

都是有效果的说明参数短时间没有实时变动。

这样就可以分析去除参数了

![image-20230803150613956](./今日头条.assets/image-20230803150613956.png)

这次来重放编辑参数

![image-20230803150727420](./今日头条.assets/image-20230803150727420.png)

这里验证了

![image-20230803150814534](./今日头条.assets/image-20230803150814534.png)

header里面大部分都删除还是可以的cookie也可以不用加

再看get的参数

![image-20230803150858038](./今日头条.assets/image-20230803150858038.png)

测试了一个参数不能少，他娘的

![image-20230803152100025](./今日头条.assets/image-20230803152100025.png)



![image-20230803154352428](./今日头条.assets/image-20230803154352428.png)

经过测试发现如果是刷新页面 channel_id为 94349549395  max_behot_time 是0

这里搜一下

![image-20230803154442745](./今日头条.assets/image-20230803154442745.png)

是一个定值，

如果滑动鼠标滚轮，向下滑动，触发feed接口

channel_id 是 0

max_behot_time 则是时间戳

所以要逆向的也就是 **_signature**

## 逆向流程

### **_signature**

直接全局搜

![image-20230803154711490](./今日头条.assets/image-20230803154711490.png)

![image-20230803154726045](./今日头条.assets/image-20230803154726045.png)

这里两处对 _signature

都打上断点吧

往下滑触发断点

![image-20230803155926552](./今日头条.assets/image-20230803155926552.png)

F.getUri(e) 是url参数，e是一个请求对象

I是加密方法

跟进去看看



![image-20230803160415778](./今日头条.assets/image-20230803160415778.png)

发现这个   加密是 这个a.call(n,o)

n 来自   window.byted_acrawler

a = n.sign

![image-20230803160637068](./今日头条.assets/image-20230803160637068.png)

所以我们只要能得到window.byted_acrawler就可以了

![image-20230803182651329](./今日头条.assets/image-20230803182651329.png)

定位进去看看是个什么玩楞

![image-20230803182719998](./今日头条.assets/image-20230803182719998.png)

是个jsvmp，扣代码肯定是不可能了

全粘下来看看吧，这个window.byted_acrawler由这个生成的

![image-20230803182958723](./今日头条.assets/image-20230803182958723.png)

用node试一下能不能行

![image-20230803183022625](./今日头条.assets/image-20230803183022625.png)

直接报错，

这个referrer是来自document

在页面上可以试试

![image-20230803183122878](./今日头条.assets/image-20230803183122878.png)

我用jsdom补一下吧

![image-20230803183242857](./今日头条.assets/image-20230803183242857.png)

补了一下dom和window

报sign找不到

可以看出来

![image-20230803183335464](./今日头条.assets/image-20230803183335464.png)

对比一下调用函数和 页面调用的有什么不同

![image-20230803183514147](./今日头条.assets/image-20230803183514147.png)

这里的b和e就是传进来的参数

经过对比

第一个参数(长的字符串)没什么区别

看一下数组

![image-20230803183700171](./今日头条.assets/image-20230803183700171.png)

![image-20230803183730947](./今日头条.assets/image-20230803183730947.png)

我执行的数组和他的不一样

页面上前三个都是undefined

我也将数组改为underfined

![image-20230803183932131](./今日头条.assets/image-20230803183932131.png)

这里将前三个改为underfiend

报错变成了 href

找不到

这个href来自于document.location.href

看一下页面的

![image-20230803184044873](./今日头条.assets/image-20230803184044873.png)

我们还是用jsdom补

![image-20230803184143388](./今日头条.assets/image-20230803184143388.png)

再次执行

![image-20230803184204645](./今日头条.assets/image-20230803184204645.png)

缺少UA了

还是一样加上

![image-20230803184227208](./今日头条.assets/image-20230803184227208.png)

再次运行

![image-20230803184242957](./今日头条.assets/image-20230803184242957.png)

sign出来了，但好像短了一点，经过测试是可以用的

这样今日头条的流程就出来了

## 总结

今日头条用到了jsdom进行补环境

看一结果吧

![image-20230803184434866](./今日头条.assets/image-20230803184434866.png)